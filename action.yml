name: "Build and deploy via GitOps repo"
description: "Will build and deploy the given docker application to the given container registry and update the deployment file in the given GitOps repository"
inputs:
  docker-working-directory:
    description: 'The path to the working directory'
    required: false
    default: '.'
  docker-file-relative:
    description: 'The path to the Dockerfile relative to the docker-working-directory'
    required: true
  app-name:
    description: 'The name of the app'
    required: true
  environment:
    description: 'The name of the environment. Typicaly either "staging" or "production"'
    required: true
  kubernetes-namespace:
    description: 'The namespace to deploy to inside the Kubernetes cluster'
    required: false
    default: default
  acr-registry:
    description: 'The name of the ACR registry to upload the image to'
    required: true
  azure-service-principal-id:
    description: 'The ID of the service principal to use when pushing the image'
    required: true
  azure-service-principal-password:
    description: 'The password of the service principal to use when pushing the image'
    required: true
  gitops-repo-url:
    description: 'The URL to the GitOps repo to update'
    required: true
  github-app-id:
    description: 'The ID of the Github app to use for updating the GitOps repo'
    required: true
  github-app-private-key-base64:
    description: 'The base64 encoded private key of the Github app to use for updating the GitOps repo'
    required: true
  github-app-installation-id:
    description: 'The installation id of the Github app to use for updating the GitOps repo'
    required: true
  gitops-deployment-file:
    description: 'The path to a file in the GitOps repo you want to update'
    required: false
runs:
  using: "composite"
  steps:
    - name: Store image name
      run: echo "IMAGE_NAME=${{ inputs.acr-registry }}.azurecr.io/${{ inputs.app-name }}_${{ inputs.environment }}:${{ github.sha }}" >> $GITHUB_ENV
      shell: bash

    - name: Login to ACR
      uses: docker/login-action@v3
      with:
        registry: ${{ inputs.acr-registry }}.azurecr.io
        username: ${{ inputs.azure-service-principal-id }}
        password: ${{ inputs.azure-service-principal-password }}

    # Detect if we're running on self-hosted runners with persistent BuildKit
    - name: Check for persistent BuildKit service
      id: check-buildkit
      run: |
        # Try to connect to the persistent BuildKit service (only available on self-hosted runners)
        # Use timeout + /dev/tcp for maximum portability (works in bash without external tools)
        if timeout 2 bash -c "echo > /dev/tcp/buildkitd.github-arc-runners.svc.cluster.local/1234" 2>/dev/null; then
          echo "buildkit-available=true" >> $GITHUB_OUTPUT
          echo "buildkit-endpoint=tcp://buildkitd.github-arc-runners.svc.cluster.local:1234" >> $GITHUB_OUTPUT
          echo "✅ Persistent BuildKit service detected - will use shared cache"
        else
          echo "buildkit-available=false" >> $GITHUB_OUTPUT
          echo "buildkit-endpoint=" >> $GITHUB_OUTPUT
          echo "ℹ️  No persistent BuildKit - using ephemeral builder (GitHub-hosted or Warp runner)"
        fi
      shell: bash
      continue-on-error: true

    # Setup BuildX - conditionally connects to persistent BuildKit if available
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        # Use persistent BuildKit on self-hosted runners, ephemeral on others
        endpoint: ${{ steps.check-buildkit.outputs.buildkit-endpoint }}
        driver: ${{ steps.check-buildkit.outputs.buildkit-available == 'true' && 'remote' || 'docker-container' }}

    - name: Build & push Docker image
      uses: docker/build-push-action@v6
      with:
        context: ${{ inputs.docker-working-directory }}
        file: ${{ inputs.docker-working-directory }}/${{ inputs.docker-file-relative }}
        push: true
        tags: ${{ env.IMAGE_NAME }}

    # GitOps deploy
    - name: Push Deployment Update
      uses: likvido/action-deployment-pusher@v2.6
      with:
        repo-url: ${{ inputs.gitops-repo-url }}
        environment: ${{ inputs.environment }}
        namespace: ${{ inputs.kubernetes-namespace }}
        app-name: ${{ inputs.app-name }}
        github-app-id: ${{ inputs.github-app-id }}
        github-app-private-key: ${{ inputs.github-app-private-key-base64 }}
        installation-id: ${{ inputs.github-app-installation-id }}
        new-image-name: ${{ env.IMAGE_NAME }}
        deployment-file: ${{ inputs.gitops-deployment-file }}
